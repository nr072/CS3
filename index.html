<!DOCTYPE html>
<html>

<head>

    <title>CS3 - CSS rule sorter</title>

    <meta charset="utf-8">

    <style>

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            --body-color: beige;
            background-color: var(--body-color);
            font-family: sans-serif;
            font-size: 12px;
            margin-bottom: 50px;
        }

        span.noscript {
            background-color: rgba(245, 215, 0, 1);
            box-shadow: 1px 1px 15px 42px rgba(0, 0, 0, 0.5);
            left: 50%;
            outline: 40px solid rgba(245, 215, 0, 1);    /* instead of padding */
            position: fixed;
            top: 50%;
            transform: translateX(-50%) translateY(-50%);
        }

        span.noscript::before {
            content: "This site is thirsty! Give it some JS...";
        }
        
        a {
            color: teal;
            text-decoration: none;
        }



        .hidden {
            display: none;
        }

        .options-cont {
            display: flex;
            justify-content: space-between;
        }

        .options-cont,
        .box-cont .box {
            margin: 20px 4vw;
        }

        .btn-wrap:not(.inner) {
            margin-right: 1rem;
        }

        .btn-wrap input[type="radio"] {
            display: none;
        }

        .btn-wrap input[type="radio"]:checked + label span.btn {
            background-color: rgba(80, 80, 80);
            color: #fff;
        }

        .btn-wrap input[type="radio"]:checked ~ .btn-wrap.hidden {
            display: inline-block;
        }

        span.btn {
            padding: 0.25rem 1rem;
            border: 1px solid rgba(127, 127, 127);
            transition: all 0.3s ease;
            margin-right: 0.25rem;
        }

        span.btn:hover {
            background-color: rgba(80, 80, 80);
            color: #fff;
            cursor: pointer;
        }

        .box-cont {
            display: flex;
            justify-content: space-between;
        }

        .box-cont .box {
            border: 1px solid #ccc;
            display: inline-block;
            font-family: monospace;
            font-size: 0.6rem;
            max-height: 500px;
            min-height: 100px;
            overflow-y: auto;
            padding: 5px;
            width: 46vw;
        }

        .box-cont .box:focus {
            outline: none;
        }

        .box-cont .box.active {
            border-color: #aaa;
        }

        @media (max-width: 576px) {
            .box-cont {
                display: block;
            }

            .box-cont .box {
                display: block;
                width: 92vw;
            }
        }

        .footer-cont {
            color: #aaa;
            font-size: 0.6rem;
            padding: 0.5rem 1rem;
            text-align: right;
            position: fixed;
            bottom: 0;
            background-color: var(--body-color);
            width: 100%;
        }

    </style>

</head>



<body>

    <noscript><span class="noscript"></span></noscript>

    <div class="cont options-cont">
        <div>
            <span class="btn-wrap">
                <input id="btn_format_pretty" type="radio" name="format" checked="true">
                <label for="btn_format_pretty">
                    <span class="btn" title="The selector(s) along with the starting curly brace, the ending curly brace, and each rule must be on separate lines in the input. Multiple selectors may be present, both in separate lines and a sinlge line.">Pretty</span>
                </label>
            </span>
            <span class="btn-wrap">
                <input id="btn_format_one" type="radio" name="format">
                <label for="btn_format_one">
                    <span class="btn" title="All rules (separated by semicolons), preceded by all selectors (separated by commas) along with the strating curly brace, and followed by the ending curly brace must be on the same line in the input. Multiple selectors may be present but must be one the same line. Each ruleset block (inlcuding all selectors) must occupy only one line. Nested scopes (e.g., media queries) are not supported.">One-line</span>
                </label>
                <span class="btn-wrap inner hidden">
                    <input id="btn_format_one_strict" type="radio" name="format_one" checked="true">
                    <label for="btn_format_one_strict">
                        <span class="btn" title="Strict mode (abortive): Execution is aborted if any non-empty line that is not a complete, one-line ruleset block (e.g., comments, multiple selectors placed on separate lines) is detected. Empty lines are tolerated due to consideration about readability.">Strict</span>
                    </label>
                </span>
                <span class="btn-wrap inner hidden">
                    <input id="btn_format_one_lax" type="radio" name="format_one">
                    <label for="btn_format_one_lax">
                        <span class="btn" title="Lax mode (exclusive): All non-empty lines that are not complete, one-line ruleset blocks (e.g., comments, multiple selectors placed on separate lines, incomplete ruleset blocks) are removed, but execution is not aborted. In case of multiple selectors on separate lines, this mode removes all but the last selector (the one on the same line as the block) providing its line contains a complete ruleset block. Empty lines are preserved.">Lax</span>
                    </label>
                </span>
            </span>
        </div>
        <div>
            <span id="sort_btn" class="btn sort-btn">Sort</span>
        </div>
    </div>

    <div class="cont box-cont">
        <div id="in" class="box in" contenteditable="true"></div>
        <div id="out" class="box out"></div>
    </div>

    <div class="footer-cont">
        <span>v0.2.4</span>
    </div>

</body>



<script>

    "use strict";

    focus_box(1);

    const sort_btn = document.getElementById("sort_btn");
    sort_btn.addEventListener("click", sort_css);



    function focus_box(box_num) {
        const boxes = document.querySelectorAll(".box-cont .box");
        if (box_num === 1) {
            boxes[0].focus();
            boxes[0].classList.add("active");
            boxes[1].classList.remove("active");
        } else if (box_num === 2) {
            boxes[0].blur();
            boxes[0].classList.remove("active");
            boxes[1].classList.add("active");
        }
    }



    function clear_output() {
        document.getElementById("out").innerText = "";
    }



    // Get selected CSS format.
    function get_format() {
        const inputs = document.getElementsByName("format");
        for (let i = 0; i < inputs.length; ++i) {
            if (inputs[i].checked) {
                return inputs[i].id === "btn_format_pretty"
                    ? "pretty"
                    : inputs[i].id === "btn_format_one"
                        ? "one"
                        : false;
            }
        }
    }



    // Get the selected mode for the selected format.
    function get_mode(format) {

        const inputs = format === "one"
            ? document.getElementsByName("format_one")
            : null;

        if (!inputs || !inputs.length) {
            return null;
        }

        for (let i = 0; i < inputs.length; ++i) {
            if (inputs[i].checked) {
                return inputs[i].id === "btn_format_one_strict"
                    ? "strict"
                    : inputs[i].id === "btn_format_one_lax"
                        ? "lax"
                        : null;
            }
        }

    }



    function sort_css() {

        clear_output();

        const in_field = document.getElementById("in");
        const css = in_field.innerText;
        if (!css.trim()) {
            focus_box(1);
            console.log("Error: Empty input! Aborting.");
            return;
        }

        // Do not proceed unless at least 2 rules present.
        const lines = css.split("\n");
        if (lines.length < 4) {
            console.log("Error: Insufficient number of rules! Aborting.");
            return;
        }

        const format = get_format();
        if (!format) {
            console.log("Error: CSS format not selected! Aborting.");
            return;
        }

        const mode = get_mode(format);
        if (!mode) {
            console.log("Error: Mode not selected! Aborting.");
            return;
        }

        if (format === "one" && mode === "strict") {
            console.log("Error: Strict node functionality not added yet! Aborting.");
            return;
        }

        const css_sorted = [];

        lines.forEach(line => {

            // Sorting mechanism for "pretty"-formated CSS.
            if (format === "pretty") {

                let block = [];
                let is_in_block = false;

                // If starting line of block, add as sorted.
                if (line.split("{").length === 2) {
                    is_in_block = true;
                    css_sorted.push(line);
                }

                // If ending line, sort current block and add them as sorted, and
                // then add this line as sorted.
                else if (line.split("}").length === 2) {

                    is_in_block = false;
                    const block_sorted = block.sort();
                    block = [];

                    // Store all non-empty rule lines.
                    block_sorted.forEach(rule => {
                        if (rule.trim()) {
                            css_sorted.push(rule);
                        }
                    });

                    // Then add current ending line.
                    css_sorted.push(line);

                }

                // If in-block line, store in array to sort.
                else if (is_in_block) {
                    block.push(line);
                }

                // Add line breaks, empty lines, and comments as sorted. (Ignore
                // these, basically.)
                else {
                    css_sorted.push(line);
                }

            }

            // Sorting mechanism for CSS with one-line rulesets (or blocks).
            else if (format === "one") {

                const has_starting_cb = line.split("{").length === 2;
                const has_ending_cb = line.split("}").length === 2;
                const is_block = has_starting_cb && has_ending_cb;

                // Keep empty lines as is. They could be there for readability.
                if (!line.trim()) {
                    css_sorted.push(line);
                }

                // For complete, one-line blocks: Take rules, split using
                // semicolons, sort, join, and recreate block.
                else if (is_block) {

                    const selector = line.split("{")[0];
                    const rules_line = line.split("{")[1].split("}")[0];

                    // Skip single-rule blocks.
                    const rules = rules_line.split(";");
                    const rules_sorted = rules.length === 1
                        ? [rules_line]
                        : rules.length === 2
                            ? (!rules[0].trim() || !rules[1].trim())
                                ? [rules_line]
                                : rules.sort()
                            : rules.sort()

                    // Recreate block with sorted rules (excluding empty array
                    // item created due to the "split()" function), and add
                    // the selector(s) and the wrapping curly braces.
                    const block_sorted = selector + "{" +
                        rules_sorted.filter(rule => rule).join(";") +
                        "}";

                    css_sorted.push(block_sorted);

                }

                // Remove selectors (followed with commas), comments, partial
                // blocks, and any other non-empty line.
                else {
                    console.log("Warning: Unacceptable line detected! Removing.");
                }

            }

        });

        // Join all sorted lines, and show as output.
        const out_field = document.getElementById("out");
        out_field.innerText = css_sorted.join("\n");

        // Scroll up to match sorted for easier side-by-side comparison.
        in_field.scrollTop = 0;

        // Focus the output box.
        focus_box(2);

    }

</script>

</html>
